### 1. 类的基础
Java定义了8种基本数据类型，除了这8种数据类型，其它数据类型均用“类”表达。

##### 1.1 类的基本概念
类可以说是函数的容器，更多时候，类表示自定义的数据类型。

1. 函数容器
比如Java API中的类Math，其中很多函数我们都可以直接调用，比如Math.abs(-1)返回1。这些函数都有相同的修饰符：public static。
- static表示类方法，也叫静态方法。与类方法相对的是实例方法，实例方法没有static修饰符，必须通过实例或者对象来调用。
- public表示函数是公开的，可以在任何地方被外部调用。private表示是私有的，函数只能在同一个类中被调用。

|关键字|说明|
|:---|:---|
|public|可修饰成员变量、成员方法、构造方法，表示可被外部访问|
|protected|可修饰成员变量、成员方法、构造方法，只能被同一包内的类使用|
|private|可修饰成员变量、成员方法、构造方法，只能在类内部使用|
|static|修饰类变量、类方法、内部类|
|final|修饰类变量、实例变量表示只能被赋值一次，修饰类表示该类不能被继承，修饰类方法表示不能被重写|
|this|表示当前实例，可用于调用当前实例的其他构造方法、实例变量、实例方法|
|super|指代父类，可用于调用父类的构造方法，访问父类变量和方法|

2. 自定义数据类型
一个数据类型由其包含的属性和可以进行的操作组成，属性可以分为是类型本身具有的属性和具体实例具有的属性，同样操作也可以分为类型本身可以进行的操作和具体实例可以进行的操作。
- 一个数据类型主要有4部分：
	- 类型本身具有的属性，通过类变量（static变量）体现。
	- 类型本身可以进行的操作，通过类方法（static方法）体现。
	- 类型实例具有的属性，通过实例变量（非static变量）体现。
	- 类型实例可以进行的操作，通过实例方法（非static方法）体现。

>注意
>类方法只能访问类变量，不能访问实例变量，可以调用类方法，不能调用实例方法。
>实例方法可以访问实例变量、实例方法，也能使用类变量、类方法。

3. 类和对象的生命周期
- 程序运行，通过new创建类的对象或访问类变量、类方法，类被加载进内存，一般程序结束才会释放。每当new创建新对象，就会产生新的对象实例变量。每个对象除了保留实例变量值，还保存着类的地址，以便访问对应类。对象释放由Java垃圾回收机制管理，当对象不再被使用时会被自动释放。
- 实例方法可以理解为多了参数`this`的静态方法，对象调用实例方法，并将对象自己作为参数传给this。
> 对象跟数组相似，有两块内存，保存地址的部分分配在栈中，保存实际内容的部分分配在堆中。栈中的内存是自动管理的，入栈分配空间，出栈释放空间。堆中的内存被垃圾回收机制管理，没有活跃变量指向堆中的对象时，对应的空间就会被释放。

##### 1.2 类的特性
1. 封装：每个类封装内部实现细节，对外提供高层次的使用方法，使其他类能在更高层直接使用，而不必考虑内部细节。
2. 继承：子类继承父类的属性和行为，但可以增加子类特有的属性和行为。使用继承可以复用代码，还可以用父类管理不同的子类对象。
3. 多态：父类变量，实际可以引用多种子类类型的对象。声明类型称为静态类型，实际类型称为动态类型。实际调用中，会调用动态类型的实现方法，这种行为成为方法的动态绑定。使用多态，可以统一处理不同对象并实现每个对象特性，而不需关注对象的实际类型。

### 2. 类的继承
Java中所有类都有一个父类Object。

##### 2.1 继承的基础

1. Object
Java所有类的根父类。

|方法|说明|
|:--|:--|
|equals(Object obj):boolean||
|getClass():Class\<?>|返回对象的类|
|hashCode():int|返回对象的哈希值|
|notify():void||
|notifyAll():void||
|toString():String|返回对象的文本描述|
|wait():void||

2. 继承
- Java使用extends关键字表示继承关系，一个类只能继承一个父类
- 子类不能直接访问父类的私有属性和方法
- 子类继承了父类所有的属性和方法
```java
public class Father{

}

public class Son extends Father{

}
```

4. 重写方法
子类定义和父类一样的方法，并重新实现，使用`@Override`注释

##### 2.2 继承的细节
1. 构造方法
子类可通过super调用父类的构造方法，如果子类没有使用super，java会自动调用父类的默认构造方法。
若父类没有默认构造方法，所有子类就都必须在构造方法中使用super调用父类的带参构造方法，否则会出现编译错误。

2. 重载和重写
- 重载：方法名字相同，但是参数签名不同（参数个数、类型、顺序都可不同）。
- 重写：子类重写与父类有相同参数签名的方法，用`@Override`声明

3. 父子类型转换
- 向上转型：子类型的对象可以赋值给父类型的引用
- “向下转型”：父类型的变量不一定可以赋值给子类型的引用，语法上可以强制类型转换，能否成功取决于父类变量的动态类型是否为子类类型。
- 判断父类对象是否是某个子类类型：`instanceOf`

4. 继承访问权限

|修饰符|说明|
|:--|:---|
|public|表示可以被外部访问|
|protected|表示可以被同一包中的类访问|
|private|表示只能内部使用|

5. 可见性重写
子类重写父类方法时，子类方法不能降低父类方法的可见性。
- 父类方法是public，子类必须是public。
- 父类方法是protected，子类可以是public、protected。
- 父类方法是private，子类可以是public、protected、private。

6. 防止继承final
final修饰类，表示类不能被继承。
final修饰类方法，表示该方法不能被子类重写。

##### 2.3 继承的实现原理
1. 类加载过程
Java中类是动态加载的，第一次使用这个类时才会加载。加载类时，先查看其父类是否加载，没有加载则会先加载其父类。过程：
- 加载父类
- 设置父子关系
- 执行类初始化代码
内存分为栈和堆，栈存放函数的局部变量，堆存放动态分配的对象，还有一个方法区存放类的信息（即Class）。

2. 对象创建过程
类加载后通过new创建对象，过程：
- 分配内存
- 给所有实例变量赋予默认值
- 执行实例初始化代码
初始化代码的执行同样先从父类开始，每个对象除了保存类的实例变量，还保存实际类信息的引用。类类型的引用变量存在栈中，指向的对象存在堆中，堆中的对象还存着方法区对应类信息的地址。

3. 方法调用过程
- object.action()
执行上述方法时，先从对象object的实际类型类信息中查找，找不到则查找父类型类信息。

> 如果对象的引用类型是父类，实际类型是子类，也先从实际类型的类信息中查找。这也称为方法的动态绑定：根据对象的实际类型查找要执行的方法，子类型中找不到再查找父类。

- 虚方法表
如果继承层次太深，而调用方法位于比较上层的父类时，调用效率就会降低，因为每次调用都需要查找。所以，大多数系统使用虚方法表来优化调用效率。

虚方法表：类加载时为每一个类创建一个表（也就是说，虚方法表在方法区中），记录该类的对象所有动态绑定的方法及其地址，一个方法只有一条记录，子类重写父类方法后只会保留子类的。

4. 变量访问过程
无论是类变量还是实际变量，其访问都是静态绑定的。通过对象访问变量，Java会转换为直接通过类访问变量。
实例变量中，private类型不能直接访问，public类型则访问的是对象的类定义的实际变量。

##### 2.4 继承的双面性
1. 缺点
继承是一把双刃剑，在有诸多优点的同时，还有一些缺点。
- 继承破坏封装
 子类与父类之间是细节依赖，子类需要知道父类的实现细节，才可以扩展父类。父类不能随意增加公开方法，如果添加，子类必须重写才能确保方法的正确性。
- 继承没有反应is-a关系

2. 解决办法
- 避免使用继承
1) 使用final关键字避免类被继承
2) 优先使用组合而非继承（注入）
3) 使用接口
- 正确使用继承

### 3. 接口
只将对象看做某种数据类型还是会有限制，因为更多时候实际需要对象拥有某种能力，而接口就可以用来表示这种能力。

##### 3.1 接口的基础
接口声明了一组能力，自己没有实现这个能力。接口时双方按约定交互，但双方并不直接依赖。
1. 定义接口，比如Java的Comparable接口
```java
public interface Comparable{
	int compareTo(Object o);
}
```
- 使用`interface`关键字声明接口，修饰符一般为public
- 接口里定义的方法没有方法实体，接口不能实现方法，方法默认都是public abstract

2. 实现接口
```java
public class MyNumber implements Comparable{
	@Override
	public int compareTo(Object o){
		//...
	}
}
```
- 通过`implements`关键字实现接口
- 实现接口必须重写接口中的方法
- 继承只能单一继承，但接口可以多个实现
```java
public class Child extends Base implements Interface1,Interface2,Interface3{
	//...
}
```

3. 使用接口
接口不能使用new直接创建对象，对象只能通过实现该接口的类来创建，但可以声明接口类型的变量。
```java
Comparable n=new MyNumber(1);
```
这种使用方法，可以让开发者只关注接口的实现，不需要关心实际实现接口的对象的类型。

4. 接口的细节
- 接口的变量
接口中可以定义变量，但变量的默认修饰符是public static final，并且可用`接口名.变量名`使用
- 接口的继承
接口跟类一样也可以继承其他接口，不同的是接口可以继承多个父接口（接口不能继承类）。
```java
public interface IBase1{

}
public interface IBase2{

}
public interface IChild extends IBase1,IBase2{

}
```
- 类的继承与接口
类的继承可以跟实现接口共存，一个类只能继承一个父类，但可以实现多个接口。
- instanceof
对象也可以使用`instanceof`判断是否实现了某接口。
- 静态方法和默认方法
Java8之后，允许接口定义静态方法和默认方法，可以有实现体，可以通过`接口名.方法名`调用。
```java
public interface Interface1{
	void iMethod();
	public static void iStaticMethod(){
		//...
	}
	default void iDefaulrMethod(){
		//...
	}
}
```
使用默认方法和静态方法，更新接口而无需更新接口的实现类，可以方便接口的更新。

##### 3.2 使用接口替代继承
使用组合和接口，可以像继承一样实现统一处理对象、复用代码的功能。（在接口的实现中加入依赖注入）

### 4. 抽象类
抽象类介于类和接口之间，表达抽象的概念。

##### 4.1 抽象类和抽象方法
抽象类表达抽象概念，抽象方法只有声明，没有具体实现，接口中的方法都是抽象方法，抽象使用`abstract`关键字声明。
```java
public abstract class AbstractClass{
	public abstract void abstractMethod();
}
```
定义了抽象方法的类必须被声明为抽象类，但是抽象类可以没有抽象方法。抽象类可以定义具体方法、实例变量，但是抽象类不能创建对象实例，要创建对象实例必须使用具体子类。

##### 4.1 抽象类和接口
接口和抽象类有诸多相似：不能直接用于创建对象实例，接口的方法都是抽象方法。也有诸多不同：接口不能定义实例变量但抽象类可以，类只能继承一个父类但可以实现多个接口。

抽象类和接口经常配合使用，接口声明能力，抽象类提供默认实现，一个接口经常有对应的抽象类。Java中：

|接口|抽象类|
|:--|:--|
|Collection|AbstractCollection|
|List|AbstractList|
|Map|AvstractMap|

### 5. 内部类
在一个类内部的类，一般内部类与包含它的类有密切关系，而与外部类关系不大，可以对外部隐藏、更好封装。
内部类只是编译器层面的概念，对于虚拟机而言，每个内部类最后都会被编译成独立的类，生成独立的字节码文件。
内部类的种类：
- 静态内部类
- 成员内部类
- 方法内部类
- 匿名内部类

##### 5.1 静态内部类
与静态方法、静态变量一样，使用`static`修饰符。
```java
public class OuterClass{
	//...
	public static class StaticInnerClass{
		//...
	}
}
```

##### 5.2 成员内部类
成员内部类无需`static`修饰
```java
public class OuterClass{
	//...
	public class InnerClass{
		//...
	}
}
```

##### 5.3 方法内部类
定义在方法体中的类
```java
public class OuterClass{
	//...
	public void outerMethod(){
		//...
		class InnerClass{
			//...
		}
	}
}
```
方法内部类只能在定义类的方法内部使用，实例方法的内部类可以访问外部类的变量和方法，静态方法的内部类只能访问外部类的静态变量和静态方法。方法内部类还可访问方法的参数和局部变量，但这些变量必须声明为final。
> 实际上，方法内部类操作的不是外部变量，而是自己的实例变量，但这些变量的值与外部变量一样，对这些变量操作不会改变外部变量，为避免混淆才规定必须声明为final。如果确实需要改变，可将变量改为只含该变量的数组，然后修改数组的值。

##### 5.4 匿名内部类
1. 匿名内部类没有单独的类定义，在创建对象时同时定义。
```java
public class OuterClass{
	//...
	public void method{
		Object ic=new InnerClass{
			//...
		}
	}
}
```
2. 调用方法时，很多方法只需要一个接口参数，使用匿名内部类可以更加简洁。比如Arrays.sort()的使用：
```java
public void sortIgnoreCase(String[] strs){  
    Arrays.sort(strs, new Comparator<String>() {  
        public int compare(String o1, String o2) {  
            return o1.compareToIgnoreCase(o2);  
        }  
    });  
}
```

### 6. 枚举
枚举是特殊的数据，其取值是有限的，可枚举出来。

##### 6.1 基础
1. 枚举声明
```java
public enum Size{
	SMALL,MEDIUM,LARGE
}
```
- 使用enum关键字
2. 使用
```java
Size size=Size.SMALL
System.out.println(size.toString());
System.out.println(size.name());
System.out.println(size.ordinal());
System.out.println(Size.SMALL==Size.valueOf("SMALL")); //true
System.out.println(Size.values());
```
- toString方法返回其字面值，name方法是枚举自带的方法，作用与toString方法一样。
- ordinal方法返回枚举值在声明时的顺序，从0开始。枚举实现了Comparable接口。
- valueOf方法返回字符串对应的枚举值，values方法返回包括所有枚举值的数组，顺序为声明顺序。
- 枚举变量可用equals和\=\=比较，结果是一致的。
3. 好处
- 枚举更加简洁
- 枚举更加安全，枚举类型变量值要么为枚举值之一，要么为null
- 枚举类型自带很多方法，方便使用
4. 实现
枚举类型实际上会被Java编译器转换为对应的类，该类继承了Enum类，并且是不可继承的final类，枚举值实际上是final静态变量，不能修改。