### 1. 类的基础
Java定义了8种基本数据类型，除了这8种数据类型，其它数据类型均用“类”表达。

##### 1.1 类的基本概念
类可以说是函数的容器，更多时候，类表示自定义的数据类型。

1. 函数容器
比如Java API中的类Math，其中很多函数我们都可以直接调用，比如Math.abs(-1)返回1。这些函数都有相同的修饰符：public static。
- static表示类方法，也叫静态方法。与类方法相对的是实例方法，实例方法没有static修饰符，必须通过实例或者对象来调用。
- public表示函数是公开的，可以在任何地方被外部调用。private表示是私有的，函数只能在同一个类中被调用。

|关键字|说明|
|:---|:---|
|public|可修饰成员变量、成员方法、构造方法，表示可被外部访问|
|protected|可修饰成员变量、成员方法、构造方法，只能被同一包内的类使用|
|private|可修饰成员变量、成员方法、构造方法，只能在类内部使用|
|static|修饰类变量、类方法、内部类|
|final|修饰类变量、实例变量表示只能被赋值一次，修饰类表示该类不能被继承，修饰类方法表示不能被重写|
|this|表示当前实例，可用于调用当前实例的其他构造方法、实例变量、实例方法|
|super|指代父类，可用于调用父类的构造方法，访问父类变量和方法|

2. 自定义数据类型
一个数据类型由其包含的属性和可以进行的操作组成，属性可以分为是类型本身具有的属性和具体实例具有的属性，同样操作也可以分为类型本身可以进行的操作和具体实例可以进行的操作。
- 一个数据类型主要有4部分：
	- 类型本身具有的属性，通过类变量（static变量）体现。
	- 类型本身可以进行的操作，通过类方法（static方法）体现。
	- 类型实例具有的属性，通过实例变量（非static变量）体现。
	- 类型实例可以进行的操作，通过实例方法（非static方法）体现。

>注意
>类方法只能访问类变量，不能访问实例变量，可以调用类方法，不能调用实例方法。
>实例方法可以访问实例变量、实例方法，也能使用类变量、类方法。

3. 类和对象的生命周期
- 程序运行，通过new创建类的对象或访问类变量、类方法，类被加载进内存，一般程序结束才会释放。每当new创建新对象，就会产生新的对象实例变量。每个对象除了保留实例变量值，还保存着类的地址，以便访问对应类。对象释放由Java垃圾回收机制管理，当对象不再被使用时会被自动释放。
- 实例方法可以理解为多了参数`this`的静态方法，对象调用实例方法，并将对象自己作为参数传给this。
> 对象跟数组相似，有两块内存，保存地址的部分分配在栈中，保存实际内容的部分分配在堆中。栈中的内存是自动管理的，入栈分配空间，出栈释放空间。堆中的内存被垃圾回收机制管理，没有活跃变量指向堆中的对象时，对应的空间就会被释放。

##### 1.2 类的特性
1. 封装：每个类封装内部实现细节，对外提供高层次的使用方法，使其他类能在更高层直接使用，而不必考虑内部细节。
2. 继承：子类继承父类的属性和行为，但可以增加子类特有的属性和行为。使用继承可以复用代码，还可以用父类管理不同的子类对象。
3. 多态：父类变量，实际可以引用多种子类类型的对象。声明类型称为静态类型，实际类型称为动态类型。实际调用中，会调用动态类型的实现方法，这种行为成为方法的动态绑定。使用多态，可以统一处理不同对象并实现每个对象特性，而不需关注对象的实际类型。

### 2. 类的继承
Java中所有类都有一个父类Object。

##### 2.1 继承的基础

1. Object
Java所有类的根父类。

|方法|说明|
|:--|:--|
|equals(Object obj):boolean||
|getClass():Class\<?>|返回对象的类|
|hashCode():int|返回对象的哈希值|
|notify():void||
|notifyAll():void||
|toString():String|返回对象的文本描述|
|wait():void||

2. 继承
- Java使用extends关键字表示继承关系，一个类只能继承一个父类
- 子类不能直接访问父类的私有属性和方法
- 子类继承了父类所有的属性和方法
```java
public class Father{

}

public class Son extends Father{

}
```

4. 重写方法
子类定义和父类一样的方法，并重新实现，使用`@Override`注释

##### 2.2 继承的细节
1. 构造方法
子类可通过super调用父类的构造方法，如果子类没有使用super，java会自动调用父类的默认构造方法。
若父类没有默认构造方法，所有子类就都必须在构造方法中使用super调用父类的带参构造方法，否则会出现编译错误。

2. 重载和重写
- 重载：方法名字相同，但是参数签名不同（参数个数、类型、顺序都可不同）。
- 重写：子类重写与父类有相同参数签名的方法，用`@Override`声明

3. 父子类型转换
- 向上转型：子类型的对象可以赋值给父类型的引用
- “向下转型”：父类型的变量不一定可以赋值给子类型的引用，语法上可以强制类型转换，能否成功取决于父类变量的动态类型是否为子类类型。
- 判断父类对象是否是某个子类类型：`instanceOf`

4. 继承访问权限

|修饰符|说明|
|:--|:---|
|public|表示可以被外部访问|
|protected|表示可以被同一包中的类访问|
|private|表示只能内部使用|

5. 可见性重写
子类重写父类方法时，子类方法不能降低父类方法的可见性。
- 父类方法是public，子类必须是public。
- 父类方法是protected，子类可以是public、protected。
- 父类方法是private，子类可以是public、protected、private。

6. 防止继承final
final修饰类，表示类不能被继承。
final修饰类方法，表示该方法不能被子类重写。

##### 2.3 继承的实现原理
1. 类加载过程
Java中类是动态加载的，第一次使用这个类时才会加载。加载类时，先查看其父类是否加载，没有加载则会先加载其父类。过程：
- 加载父类
- 设置父子关系
- 执行类初始化代码
内存分为栈和堆，栈存放函数的局部变量，堆存放动态分配的对象，还有一个方法区存放类的信息（即Class）。

2. 对象创建过程
类加载后通过new创建对象，过程：
- 分配内存
- 给所有实例变量赋予默认值
- 执行实例初始化代码
初始化代码的执行同样先从父类开始，每个对象除了保存类的实例变量，还保存实际类信息的引用。类类型的引用变量存在栈中，指向的对象存在堆中，堆中的对象还存着方法区对应类信息的地址。

3. 方法调用过程
- object.action()
执行上述方法时，先从对象object的实际类型类信息中查找，找不到则查找父类型类信息。

> 如果对象的引用类型是父类，实际类型是子类，也先从实际类型的类信息中查找。这也称为方法的动态绑定：根据对象的实际类型查找要执行的方法，子类型中找不到再查找父类。

- 虚方法表
如果继承层次太深，而调用方法位于比较上层的父类时，调用效率就会降低，因为每次调用都需要查找。所以，大多数系统使用虚方法表来优化调用效率。

虚方法表：类加载时为每一个类创建一个表（也就是说，虚方法表在方法区中），记录该类的对象所有动态绑定的方法及其地址，一个方法只有一条记录，子类重写父类方法后只会保留子类的。

4. 变量访问过程
无论是类变量还是实际变量，其访问都是静态绑定的。通过对象访问变量，Java会转换为直接通过类访问变量。
实例变量中，private类型不能直接访问，public类型则访问的是对象的类定义的实际变量。

##### 2.4 继承的双面性
1. 缺点
继承是一把双刃剑，在有诸多优点的同时，还有一些缺点。
- 继承破坏封装
 子类与父类之间是细节依赖，子类需要知道父类的实现细节，才可以扩展父类。父类不能随意增加公开方法，如果添加，子类必须重写才能确保方法的正确性。
- 继承没有反应is-a关系

2. 解决办法
- 避免使用继承
1) 使用final关键字避免类被继承
2) 优先使用组合而非继承（注入）
3) 使用接口
- 正确使用继承

